/**
 * Documentation Video Post-Processing
 *
 * Optimizes and organizes videos generated by Playwright tests.
 * - Copies from test-results/ to docs/videos/
 * - Applies ffmpeg compression presets
 * - Generates thumbnail images
 */

import { mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { existsSync } from 'node:fs';

const execAsync = promisify(exec);

/**
 * Video type configuration
 */
const videoConfig = {
  highlights: {
    dir: 'docs/videos/highlights',
    bitrate: '500K',
    fps: 15,
    crf: 32,
    'cpu-used': 4
  },
  workflows: {
    dir: 'docs/videos/workflows',
    bitrate: '1M',
    fps: 24,
    crf: 28,
    'cpu-used': 2
  }
} as const;

/**
 * Optimize a video using ffmpeg
 */
async function optimizeVideo(
  input: string,
  output: string,
  type: keyof typeof videoConfig
): Promise<void> {
  const config = videoConfig[type];

  const args = [
    '-i', input,
    '-c:v', 'libvpx-vp9',
    '-b:v', config.bitrate,
    '-r', String(config.fps),
    '-crf', String(config.crf),
    '-cpu-used', String(config['cpu-used']),
    '-y',
    output
  ];

  const cmd = `ffmpeg ${args.join(' ')}`;

  try {
    await execAsync(cmd);
  } catch (error) {
    // If optimization fails, just copy the file
    console.warn(`  ‚ö†Ô∏è  Optimization failed, copying original: ${error}`);
    const { copyFile } = await import('node:fs/promises');
    await copyFile(input, output);
  }
}

/**
 * Generate a thumbnail image from video
 */
async function generateThumbnail(
  videoPath: string,
  thumbnailPath: string
): Promise<void> {
  // Extract frame at 50% of video duration
  const args = [
    '-i', videoPath,
    '-ss', '00:00:01', // Take frame at 1 second (or use 50% duration)
    '-vframes', '1',
    '-vf', 'scale=320:-1', // Resize to 320px width
    '-y',
    thumbnailPath
  ];

  const cmd = `ffmpeg ${args.join(' ')} 2>/dev/null`;

  try {
    await execAsync(cmd);
    console.log(`  ‚úì Generated thumbnail: ${thumbnailPath}`);
  } catch {
    // Thumbnail generation is optional, don't fail if it doesn't work
    console.warn(`  ‚ö†Ô∏è  Thumbnail generation failed for: ${videoPath}`);
  }
}

/**
 * Process a single video
 */
async function processVideo(
  name: string,
  sourcePath: string,
  type: 'highlights' | 'workflows'
): Promise<void> {
  const targetDir = videoConfig[type].dir;
  const finalPath = join(targetDir, `${name}.webm`);
  const thumbnailPath = join(targetDir, `${name}.png`);

  // Ensure output directory exists
  if (!existsSync(targetDir)) {
    await mkdir(targetDir, { recursive: true });
  }

  console.log(`\nProcessing ${name} (${type}):`);

  // Optimize video
  await optimizeVideo(sourcePath, finalPath, type);
  console.log(`  ‚úì Optimized: ${finalPath}`);

  // Get file size
  const { stat } = await import('node:fs/promises');
  const stats = await stat(finalPath);
  const sizeMB = (stats.size / 1024 / 1024).toFixed(2);
  console.log(`  üì¶ Size: ${sizeMB} MB`);

  // Generate thumbnail
  await generateThumbnail(finalPath, thumbnailPath);
}

/**
 * Main function - find and process all doc videos
 */
async function main(): Promise<void> {
  console.log('üé¨ Processing documentation videos...\n');

  // Find all doc videos from test results
  const { readdir } = await import('node:fs/promises');

  const testResultsDir = 'test-results';
  if (!existsSync(testResultsDir)) {
    console.error('‚ùå test-results/ directory not found');
    console.log('   Run tests first: bun run docs:videos');
    process.exit(1);
  }

  const entries = await readdir(testResultsDir, { withFileTypes: true });
  const videoDirs = entries
    .filter(e => e.isDirectory() && e.name.includes('doc-videos'))
    .map(e => join(testResultsDir, e.name));

  if (videoDirs.length === 0) {
    console.error('‚ùå No doc video results found');
    console.log('   Run tests first: bun run docs:videos');
    process.exit(1);
  }

  console.log(`Found ${videoDirs.length} video test result(s)\n`);

  // Process each video
  let processedCount = 0;

  for (const dir of videoDirs) {
    const videoPath = join(dir, 'video.webm');

    if (!existsSync(videoPath)) {
      continue;
    }

    // Extract video name from directory name
    const dirName = dir.split('/').pop()!;
    const match = dirName.match(/Documentation-Videos-([^(]+)-doc-videos/);

    if (!match) {
      console.warn(`‚ö†Ô∏è  Skipping: ${dirName} (unrecognized format)`);
      continue;
    }

    const testName = match[1];
    const isHighlight = [
      'test-basic',
      'command-palette',
      'bulk-operations',
      'keyboard-shortcuts',
      'character-network'
    ].includes(testName);

    const type = isHighlight ? 'highlights' : 'workflows';

    await processVideo(testName, videoPath, type);
    processedCount++;
  }

  console.log(`\n‚úÖ Processed ${processedCount} video(s)`);
  console.log('\nüìÅ Output:');
  console.log(`   Highlights: docs/videos/highlights/`);
  console.log(`   Workflows:  docs/videos/workflows/`);
}

main().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});
