'use client';

import React, { useState, useEffect, useRef } from 'react';
import { useDocumentContext } from '@/lib/context/DocumentContext';
import { Card } from '@/components/ui/card';
import { FileUpload } from './FileUpload';
import { TagToolbar } from './TagToolbar';
import { ExportButton } from './ExportButton';
import { CommandPalette } from '@/components/keyboard/CommandPalette';
import { AIModeSwitcher } from '@/components/ai/AIModeSwitcher';
import { InlineSuggestions } from '@/components/ai/InlineSuggestions';
import { BulkOperationsPanel } from './BulkOperationsPanel';
import { ValidationResultsDialog, ValidationIssue } from './ValidationResultsDialog';
import { RenderedView } from './RenderedView';
import { VisualizationPanel } from '@/components/visualization/VisualizationPanel';
import { SampleGallery } from '@/components/samples/SampleGallery';
import { QuickSearchDialog } from '@/components/search/QuickSearchDialog';
import { DialogueOutline } from '@/components/navigation/DialogueOutline';
import type { AIMode } from '@/components/ai/AIModeSwitcher';
import { DialogueSpan } from '@/lib/ai/providers';
import { useHotkeys } from 'react-hotkeys-hook';
import { Button } from '@/components/ui/button';
import { db } from '@/lib/db/PatternDB';
import { Search, Undo, Loader2, CheckCircle2, List, X, Download } from 'lucide-react';
import type { SearchResult } from '@/lib/search/QuickSearch';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { getParagraphText, applyTagToParagraph } from '@/lib/utils/teiTagging';
import { KeyboardShortcutHelp } from '@/components/keyboard/KeyboardShortcutHelp';
import { Navigation, Tag } from 'lucide-react';
import { exportToHTML, downloadFile } from '@/lib/tei/export';


export function EditorLayout() {
  const { document, updateDocument, loadSample, clearDocument } = useDocumentContext();
  const [commandPaletteOpen, setCommandPaletteOpen] = useState(false);
  const [searchDialogOpen, setSearchDialogOpen] = useState(false);
  const [aiMode, setAIMode] = useState<AIMode>('manual');
  const [suggestions, setSuggestions] = useState<DialogueSpan[]>([]);
  const [selectedText, setSelectedText] = useState<string>('');
  const [bulkPanelOpen, setBulkPanelOpen] = useState(false);
  const [vizPanelOpen, setVizPanelOpen] = useState(false);
  const [selectedPassages, setSelectedPassages] = useState<string[]>([]);
  const [highlightedPassageId, setHighlightedPassageId] = useState<string | null>(null);
  const [isBulkMode, setIsBulkMode] = useState(false);
  const [showGallery, setShowGallery] = useState(true);
  const [splitPosition, setSplitPosition] = useState(50); // Split position percentage
  const renderedViewRef = useRef<HTMLDivElement>(null);
  const [autoAppliedSuggestions, setAutoAppliedSuggestions] = useState<DialogueSpan[]>([]);
  const [isAutoApplying, setIsAutoApplying] = useState(false);
  const [autoApplyProgress, setAutoApplyProgress] = useState({ current: 0, total: 0 });
  const [showUndoToast, setShowUndoToast] = useState(false);
  const [validationDialogOpen, setValidationDialogOpen] = useState(false);
  const [validationIssues, setValidationIssues] = useState<ValidationIssue[]>([]);
  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const [outlineOpen, setOutlineOpen] = useState(false);
  const [currentPassageId, setCurrentPassageId] = useState<string | null>(null);
  const [shortcutHelpOpen, setShortcutHelpOpen] = useState(false);
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' | 'info' } | null>(null);
  const [activePassageIndex, setActivePassageIndex] = useState<number>(-1);
  const [passageElements, setPassageElements] = useState<string[]>([]);

  useHotkeys('mod+k', (e) => {
    e.preventDefault();
    setCommandPaletteOpen(true);
  });

  useHotkeys('mod+f', (e) => {
    e.preventDefault();
    setSearchDialogOpen(true);
  });

  useHotkeys('mod+b', (e) => {
    e.preventDefault();
    setBulkPanelOpen(!bulkPanelOpen);
  });

  useHotkeys('mod+o', (e) => {
    e.preventDefault();
    setOutlineOpen(!outlineOpen);
  });

  // Helper function to show toast messages
  const showToast = (message: string, type: 'success' | 'error' | 'info' = 'info') => {
    setToast({ message, type });
    setTimeout(() => setToast(null), 3000);
  };

  // Helper function to check if user is in an input field
  const isInputFocused = () => {
    const activeElement = window.document?.activeElement;
    if (!activeElement) return false;
    return activeElement instanceof HTMLInputElement ||
           activeElement instanceof HTMLTextAreaElement ||
           activeElement.getAttribute('contenteditable') === 'true';
  };

  // Helper function to get all passage IDs from the document
  const getPassageIds = () => {
    if (!document) return [];
    const p = document.parsed.TEI.text.body.p;
    const paragraphs = Array.isArray(p) ? p : (p ? [p] : []);
    return paragraphs.map((_, idx) => `passage-${idx}`);
  };

  // Update passage elements when document changes
  useEffect(() => {
    setPassageElements(getPassageIds());
    setActivePassageIndex(-1);
  }, [document]);

  // Keyboard shortcut: ? - Show keyboard shortcuts help
  useHotkeys('shift+/', (e) => {
    if (isInputFocused()) return;
    e.preventDefault();
    setShortcutHelpOpen(true);
    showToast('Keyboard shortcuts help opened', 'info');
  }, [isInputFocused]);

  // Keyboard shortcut: J - Next passage
  useHotkeys('j', (e) => {
    if (isInputFocused()) return;
    e.preventDefault();

    const passages = getPassageIds();
    if (passages.length === 0) {
      showToast('No passages to navigate', 'error');
      return;
    }

    const nextIndex = Math.min(activePassageIndex + 1, passages.length - 1);
    const passageId = passages[nextIndex];

    setActivePassageIndex(nextIndex);
    setCurrentPassageId(passageId);
    setHighlightedPassageId(passageId);

    setTimeout(() => {
      const element = document?.getElementById(passageId);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => setHighlightedPassageId(null), 3000);
      }
    }, 100);

    showToast(`Passage ${nextIndex + 1}/${passages.length}`, 'info');
  }, [isInputFocused, activePassageIndex, document]);

  // Keyboard shortcut: K - Previous passage
  useHotkeys('k', (e) => {
    if (isInputFocused()) return;
    e.preventDefault();

    const passages = getPassageIds();
    if (passages.length === 0) {
      showToast('No passages to navigate', 'error');
      return;
    }

    const prevIndex = Math.max(activePassageIndex - 1, 0);
    const passageId = passages[prevIndex];

    setActivePassageIndex(prevIndex);
    setCurrentPassageId(passageId);
    setHighlightedPassageId(passageId);

    setTimeout(() => {
      const element = document?.getElementById(passageId);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => setHighlightedPassageId(null), 3000);
      }
    }, 100);

    showToast(`Passage ${prevIndex + 1}/${passages.length}`, 'info');
  }, [isInputFocused, activePassageIndex, document]);

  // Keyboard shortcuts: 1-9 - Quick tag as speaker 1-9
  for (let i = 1; i <= 9; i++) {
    useHotkeys(
      String(i),
      (e) => {
        if (isInputFocused()) return;
        e.preventDefault();

        const speakerId = `speaker${i}`;
        const selection = window.getSelection();
        const selectedText = selection?.toString() || '';

        if (!selectedText || selectedText.trim().length === 0) {
          showToast(`No text selected - Select text first, then press ${i}`, 'error');
          return;
        }

        handleApplyTag('said', { '@who': speakerId });
        showToast(`Tagged as ${speakerId}`, 'success');
      },
      [isInputFocused, handleApplyTag]
    );
  }

  // Keyboard shortcut: A - Accept AI suggestion
  useHotkeys('a', (e) => {
    if (isInputFocused()) return;
    e.preventDefault();

    if (suggestions.length === 0) {
      showToast('No AI suggestions to accept', 'error');
      return;
    }

    // Accept the first suggestion
    const suggestion = suggestions[0];
    handleAcceptSuggestion(suggestion);
    applySuggestionToDocument(suggestion);
    showToast('AI suggestion accepted', 'success');
  }, [isInputFocused, suggestions, handleAcceptSuggestion, applySuggestionToDocument]);

  // Keyboard shortcut: X - Reject AI suggestion
  useHotkeys('x', (e) => {
    if (isInputFocused()) return;
    e.preventDefault();

    if (suggestions.length === 0) {
      showToast('No AI suggestions to reject', 'error');
      return;
    }

    // Reject the first suggestion
    const suggestion = suggestions[0];
    handleRejectSuggestion(suggestion);
    showToast('AI suggestion rejected', 'info');
  }, [isInputFocused, suggestions, handleRejectSuggestion]);

  // Split pane drag handlers
  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e: MouseEvent) => {
      if (!containerRef.current) return;

      const containerRect = containerRef.current.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const mouseX = e.clientX - containerRect.left;

      // Calculate percentage, constrain between 20% and 80%
      let newSplitPosition = (mouseX / containerWidth) * 100;
      newSplitPosition = Math.max(20, Math.min(80, newSplitPosition));

      setSplitPosition(newSplitPosition);
    };

    const handleMouseUp = () => {
      setIsDragging(false);
    };

    // Add event listeners to document for smooth dragging
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // Clean up event listeners
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging]);

  // Prevent text selection during drag
  useEffect(() => {
    if (typeof document === 'undefined' || !document?.body) return;

    if (isDragging) {
      document.body.style.userSelect = 'none';
      document.body.style.cursor = 'col-resize';
    } else {
      document.body.style.userSelect = '';
      document.body.style.cursor = '';
    }

    return () => {
      if (typeof document !== 'undefined' && document?.body) {
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
      }
    };
  }, [isDragging]);

  // Handle search result click - scroll to and highlight passage
  const handleSearchResultClick = (result: SearchResult) => {
    setHighlightedPassageId(result.id);
    setCurrentPassageId(result.id);

    // Scroll to the passage
    setTimeout(() => {
      const element = globalThis.document?.getElementById(result.id);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Clear highlight after a few seconds
        setTimeout(() => setHighlightedPassageId(null), 3000);
      }
    }, 100);
  };

  // Handle outline passage click - scroll to and highlight passage
  const handleOutlinePassageClick = (passageId: string) => {
    setHighlightedPassageId(passageId);
    setCurrentPassageId(passageId);

    // Scroll to the passage
    setTimeout(() => {
      const element = globalThis.document?.getElementById(passageId);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Clear highlight after a few seconds
        setTimeout(() => setHighlightedPassageId(null), 3000);
      }
    }, 100);
  };

  // Auto-load a default sample on first mount
  useEffect(() => {
    let isMounted = true;

    async function loadDefaultSample() {
      try {
        // Load "The Gift of the Magi" as a nice intermediate example
        if (isMounted && !document) {
          await loadSample('gift-of-the-magi');
          setShowGallery(false);
        }
      } catch (error) {
        console.error('Failed to load default sample:', error);
      }
    }

    loadDefaultSample();

    return () => {
      isMounted = false;
    };
  }, []); // Only run on mount

  const handleSampleSelect = async (sampleId: string) => {
    try {
      await loadSample(sampleId);
      setShowGallery(false);
    } catch (error) {
      console.error('Failed to load sample:', error);
    }
  };

  const handleTagAll = async (speakerId: string) => {
    if (!document) return;

    const newDoc = { ...document };
    const paragraphs = newDoc.parsed.TEI.text.body.p;
    const passagesToTag = [...selectedPassages]; // Copy before clearing

    selectedPassages.forEach(index => {
      if (paragraphs[index] && paragraphs[index].said) {
        paragraphs[index].said = paragraphs[index].said.map((s: any) => ({
          ...s,
          '@who': speakerId
        }));
      }
    });

    // Serialize and update document
    const updatedXML = document.serialize();
    updateDocument(updatedXML);
    setSelectedPassages([]);

    // Log to pattern database
    // Note: The function signature has changed, this is a placeholder
    // TODO: Update to use the correct logCorrection API
  };

  const handleSelectAllUntagged = () => {
    if (!document) return;

    const untaggedIndices = new Set<number>();
    const paragraphs = document.parsed.TEI.text.body.p;

    paragraphs.forEach((para: any, index: number) => {
      const hasUntagged = para.said?.some((s: any) => !s['@who'] || s['@who'] === '');
      if (hasUntagged) {
        untaggedIndices.add(index);
      }
    });

    setSelectedPassages(Array.from(untaggedIndices).map(String));
  };

  const handleSelectLowConfidence = () => {
    console.log('Selecting low confidence passages');
    // TODO: Implement selection logic
  };

  const handleExportSelection = () => {
    if (!document || selectedPassages.length === 0) return;

    const selectedParagraphs = selectedPassages.map(
      index => document.parsed.TEI.text.body.p[Number(index)]
    );

    const data = JSON.stringify(selectedParagraphs, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = window.document.createElement('a');
    a.href = url;
    a.download = `tei-export-${Date.now()}.json`;
    a.click();

    URL.revokeObjectURL(url);
  };

  const handleValidateSelection = async () => {
    if (!document || selectedPassages.length === 0) {
      setValidationIssues([
        {
          type: 'info',
          message: 'No passages selected for validation',
          location: { index: -1 },
          suggestion: 'Select one or more passages before validating.'
        }
      ]);
      setValidationDialogOpen(true);
      return;
    }

    const issues: ValidationIssue[] = [];
    const paragraphs = document.parsed.TEI.text.body.p;

    selectedPassages.forEach(indexStr => {
      const index = Number(indexStr);
      const para = paragraphs[index];

      if (!para) {
        issues.push({
          type: 'error',
          message: 'Paragraph not found in document',
          location: { index },
          suggestion: 'This passage may have been deleted or the document structure changed.'
        });
        return;
      }

      // Check if paragraph has any content
      const textContent = typeof para === 'string' ? para : para['#text'] || '';
      if (!textContent || textContent.trim() === '') {
        issues.push({
          type: 'warning',
          message: 'Empty paragraph detected',
          location: { index },
          suggestion: 'Consider removing this empty paragraph or adding content.'
        });
      }

      // Check if paragraph has dialogue tags
      if (!para.said || para.said.length === 0) {
        issues.push({
          type: 'info',
          message: 'No dialogue tags found in this paragraph',
          location: { index },
          suggestion: 'If this paragraph contains dialogue, consider adding <said> tags.'
        });
      } else {
        // Validate each dialogue tag
        para.said.forEach((s: any, i: number) => {
          // Check for untagged speaker
          if (!s['@who'] || s['@who'] === '') {
            issues.push({
              type: 'error',
              message: 'Untagged speaker',
              location: { index, dialogueIndex: i },
              suggestion: 'Use the "Tag All" operation to assign a speaker to this dialogue.'
            });
          }

          // Check for invalid speaker IDs
          const validSpeakers = ['speaker1', 'speaker2', 'speaker3', 'narrator'];
          if (s['@who'] && !validSpeakers.includes(s['@who'])) {
            issues.push({
              type: 'warning',
              message: `Unknown speaker ID: "${s['@who']}"`,
              location: { index, dialogueIndex: i },
              suggestion: 'Valid speaker IDs are: speaker1, speaker2, speaker3, narrator.'
            });
          }

          // Check for empty dialogue content
          const dialogueText = typeof s === 'string' ? s : s['#text'] || '';
          if (!dialogueText || dialogueText.trim() === '') {
            issues.push({
              type: 'warning',
              message: 'Empty dialogue tag',
              location: { index, dialogueIndex: i },
              suggestion: 'Remove this empty tag or add dialogue content.'
            });
          }

          // Check for very short dialogues (might be false positives)
          if (dialogueText.trim().length < 3) {
            issues.push({
              type: 'info',
              message: `Very short dialogue: "${dialogueText.trim()}"`,
              location: { index, dialogueIndex: i },
              suggestion: 'Verify this is intentional dialogue and not a punctuation mark or abbreviation.'
            });
          }
        });
      }

      // Check for potential issues with confidence (if stored in annotations)
      // This is a placeholder for when we add confidence tracking to the document structure
      if (para._confidence !== undefined && para._confidence < 0.7) {
        issues.push({
          type: 'warning',
          message: `Low confidence annotation: ${Math.round(para._confidence * 100)}%`,
          location: { index },
          suggestion: 'Review this passage manually to ensure correct speaker attribution.'
        });
      }
    });

    setValidationIssues(issues);
    setValidationDialogOpen(true);
  };

  const handleConvert = () => {
    console.log('Converting selected passages to dialogue');
    // TODO: Implement conversion logic
  };

  const handleExportHTML = () => {
    if (!document) {
      showToast('No document to export', 'error');
      return;
    }

    try {
      const html = exportToHTML(document);
      downloadFile(html, 'document.html', 'text/html');
      showToast('Exported to HTML successfully', 'success');
    } catch (error) {
      console.error('Error exporting to HTML:', error);
      showToast('Failed to export to HTML', 'error');
    }
  };

  const handleExportTEI = () => {
    if (!document) {
      showToast('No document to export', 'error');
      return;
    }

    try {
      const xml = document.serialize();
      downloadFile(xml, 'document.xml', 'application/xml');
      showToast('Exported to TEI XML successfully', 'success');
    } catch (error) {
      console.error('Error exporting to TEI:', error);
      showToast('Failed to export to TEI XML', 'error');
    }
  };

  const handleApplyTag = (tag: string, attrs?: Record<string, string>) => {
    if (!document) return;

    try {
      // Get the current selection
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return;

      const range = selection.getRangeAt(0);
      const selectedText = range.toString();

      if (!selectedText || selectedText.trim().length === 0) {
        console.warn('No text selected');
        return;
      }

      // Get the paragraphs from the document
      const newDoc = { ...document };
      const paragraphs = newDoc.parsed.TEI.text.body.p;
      const paragraphsArray = Array.isArray(paragraphs) ? paragraphs : [paragraphs];

      // Find the paragraph containing the selected text
      let foundParagraph = false;

      for (let i = 0; i < paragraphsArray.length; i++) {
        const para = paragraphsArray[i];
        const paraText = getParagraphText(para);

        if (paraText.includes(selectedText)) {
          // Update the paragraph with the tagged element
          const updatedPara = applyTagToParagraph(para, selectedText, tag, attrs);

          // Update the paragraphs array
          if (Array.isArray(paragraphs)) {
            paragraphs[i] = updatedPara;
          } else {
            newDoc.parsed.TEI.text.body.p = updatedPara;
          }

          foundParagraph = true;
          break;
        }
      }

      if (!foundParagraph) {
        console.warn('Could not find paragraph containing selected text');
        return;
      }

      // Serialize and update document
      const updatedXML = document.serialize();
      updateDocument(updatedXML);

      // Clear the selection
      selection.removeAllRanges();

      console.log(`Successfully applied <${tag}> tag to "${selectedText}"`);
    } catch (error) {
      console.error('Error applying tag:', error);
    }
  };

  const handleAcceptSuggestion = (suggestion: DialogueSpan) => {
    console.log('Accept suggestion:', suggestion);
    // TODO: Apply TEI tag with suggestion data
    setSuggestions(prev => prev.filter(s =>
      !(s.start === suggestion.start && s.end === suggestion.end)
    ));
  };

  const handleRejectSuggestion = (suggestion: DialogueSpan) => {
    console.log('Reject suggestion:', suggestion);
    setSuggestions(prev => prev.filter(s =>
      !(s.start === suggestion.start && s.end === suggestion.end)
    ));
  };

  const handleUndoAutoApplied = () => {
    console.log('Undoing auto-applied suggestions:', autoAppliedSuggestions);
    // Remove auto-applied suggestions from document
    // In a real implementation, this would revert the TEI tags
    setSuggestions(prev => [...prev, ...autoAppliedSuggestions]);
    setAutoAppliedSuggestions([]);
    setShowUndoToast(false);
  };

  // Apply a suggestion to the document (placeholder for now)
  const applySuggestionToDocument = (suggestion: DialogueSpan) => {
    // TODO: In a real implementation, this would:
    // 1. Find the paragraph containing the dialogue
    // 2. Add <said> tags around the detected text
    // 3. Serialize and update the document
    console.log('Applying suggestion to document:', suggestion);
  };

  // Auto-apply high-confidence suggestions when in auto mode
  useEffect(() => {
    let isMounted = true;
    let timeoutId: NodeJS.Timeout;

    async function autoApplySuggestions() {
      if (aiMode !== 'auto' || suggestions.length === 0 || isAutoApplying) {
        return;
      }

      // Filter high-confidence suggestions (>= 0.8)
      const highConfidenceSuggestions = suggestions.filter(s => s.confidence >= 0.8);

      if (highConfidenceSuggestions.length === 0) {
        return;
      }

      setIsAutoApplying(true);
      setAutoApplyProgress({ current: 0, total: highConfidenceSuggestions.length });

      // Apply suggestions with a small delay for visual feedback
      for (let i = 0; i < highConfidenceSuggestions.length; i++) {
        if (!isMounted) break;

        await new Promise(resolve => {
          timeoutId = setTimeout(resolve, 300); // 300ms between each application
        });

        const suggestion = highConfidenceSuggestions[i];
        applySuggestionToDocument(suggestion);

        setAutoApplyProgress({ current: i + 1, total: highConfidenceSuggestions.length });
      }

      if (isMounted) {
        // Move applied suggestions to auto-applied list
        setAutoAppliedSuggestions(prev => [...prev, ...highConfidenceSuggestions]);
        // Remove them from the suggestions list
        setSuggestions(prev => prev.filter(s =>
          !highConfidenceSuggestions.some(applied =>
            applied.start === s.start && applied.end === s.end
          )
        ));

        setIsAutoApplying(false);

        // Show undo toast
        setShowUndoToast(true);

        // Auto-hide toast after 5 seconds
        timeoutId = setTimeout(() => {
          if (isMounted) {
            setShowUndoToast(false);
          }
        }, 5000);
      }
    }

    autoApplySuggestions();

    return () => {
      isMounted = false;
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [aiMode, suggestions, isAutoApplying]);

  // Simulate AI detection when in suggest or auto mode
  useEffect(() => {
    let isMounted = true;

    async function detectDialogue() {
      if (!document || aiMode === 'manual') return;

      const text = document.parsed.TEI.text.body.p || '';

      // Simulate AI dialogue detection (placeholder until Task 13)
      const detectedSpans: DialogueSpan[] = [];
      const quoteRegex = /"([^"]+)"/g;
      let match;

      while ((match = quoteRegex.exec(text)) !== null) {
        detectedSpans.push({
          start: match.index,
          end: match.index + match[0].length,
          text: match[1],
          confidence: 0.7 + Math.random() * 0.25 // Random confidence between 0.7 and 0.95
        });
      }

      if (isMounted) {
        setSuggestions(detectedSpans);
      }
    }

    detectDialogue();

    return () => {
      isMounted = false;
    };
  }, [aiMode, document]); // Include document in dependencies

  // Track text selection for highlighting
  useEffect(() => {
    // Guard for SSR/test environment
    if (typeof window === 'undefined' || typeof window.document === 'undefined' || !window.document?.addEventListener) {
      return;
    }

    const handleSelection = () => {
      const selection = window.getSelection();
      const text = selection?.toString() || '';
      setSelectedText(text);
    };

    window.document.addEventListener('selectionchange', handleSelection);
    return () => {
      window.document.removeEventListener('selectionchange', handleSelection);
    };
  }, []); // No dependencies needed

  if (!document) {
    return (
      <div className="h-screen overflow-auto">
        <CommandPalette
        open={commandPaletteOpen}
        onClose={() => setCommandPaletteOpen(false)}
        onToggleBulkMode={() => {
          setBulkPanelOpen(!bulkPanelOpen);
          setIsBulkMode(!bulkPanelOpen);
        }}
        onToggleVisualizations={() => setVizPanelOpen(!vizPanelOpen)}
        isBulkMode={isBulkMode}
        isVizPanelOpen={vizPanelOpen}
      />
        <SampleGallery
          onSelect={(sampleId) => {
            handleSampleSelect(sampleId);
          }}
          onLoadSample={loadSample}
        />
      </div>
    );
  }

  return (
    <div className="h-screen flex flex-col">
      <CommandPalette
        open={commandPaletteOpen}
        onClose={() => setCommandPaletteOpen(false)}
        onToggleBulkMode={() => {
          setBulkPanelOpen(!bulkPanelOpen);
          setIsBulkMode(!bulkPanelOpen);
        }}
        onToggleVisualizations={() => setVizPanelOpen(!vizPanelOpen)}
        isBulkMode={isBulkMode}
        isVizPanelOpen={vizPanelOpen}
      />
      <QuickSearchDialog
        open={searchDialogOpen}
        onOpenChange={setSearchDialogOpen}
        onResultClick={handleSearchResultClick}
      />
      <BulkOperationsPanel
        isOpen={bulkPanelOpen}
        onClose={() => setBulkPanelOpen(false)}
        selectedPassages={selectedPassages}
        onTagAll={handleTagAll}
        onSelectAllUntagged={handleSelectAllUntagged}
        onSelectLowConfidence={handleSelectLowConfidence}
        onExportSelection={handleExportSelection}
        onValidate={handleValidateSelection}
        onConvert={handleConvert}
      />
      <ValidationResultsDialog
        open={validationDialogOpen}
        onOpenChange={setValidationDialogOpen}
        issues={validationIssues}
        passageCount={selectedPassages.length}
      />
      <KeyboardShortcutHelp
        open={shortcutHelpOpen}
        onClose={() => setShortcutHelpOpen(false)}
      />
      <FileUpload />
      <div className="flex items-center gap-2 p-2 border-b">
        <Button
          variant="outline"
          size="sm"
          onClick={() => {
            clearDocument();
            setShowGallery(true);
          }}
        >
          ← Back to Gallery
        </Button>
        <AIModeSwitcher mode={aiMode} onModeChange={setAIMode} />
        <TagToolbar onApplyTag={handleApplyTag} />
        <Button
          variant="outline"
          size="sm"
          onClick={() => setSearchDialogOpen(true)}
        >
          <Search className="h-4 w-4 mr-2" />
          Search
          <kbd className="ml-2 text-xs bg-muted px-2 py-1 rounded">⌘F</kbd>
        </Button>
        <Button
          variant={bulkPanelOpen ? "default" : "outline"}
          size="sm"
          onClick={() => {
            setBulkPanelOpen(!bulkPanelOpen);
            setIsBulkMode(!bulkPanelOpen);
          }}
        >
          Bulk Operations ({selectedPassages.length})
          <kbd className="ml-2 text-xs bg-muted px-2 py-1 rounded">⌘B</kbd>
        </Button>
        <Button
          variant={vizPanelOpen ? "default" : "outline"}
          size="sm"
          onClick={() => setVizPanelOpen(!vizPanelOpen)}
        >
          Visualizations
        </Button>
        <Button
          variant={outlineOpen ? "default" : "outline"}
          size="sm"
          onClick={() => setOutlineOpen(!outlineOpen)}
        >
          <List className="h-4 w-4 mr-2" />
          Outline
          <kbd className="ml-2 text-xs bg-muted px-2 py-1 rounded">⌘O</kbd>
        </Button>
      </div>
      <div ref={containerRef} className="flex-1 flex overflow-hidden">
        {/* Dialogue Outline Panel (left sidebar) */}
        {outlineOpen && (
          <>
            <div className="w-80 bg-background border-r shadow-lg overflow-hidden flex flex-col">
              <div className="flex justify-between items-center p-4 border-b">
                <h2 className="text-lg font-semibold">Dialogue Outline</h2>
                <Button variant="ghost" size="sm" onClick={() => setOutlineOpen(false)}>
                  <X className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex-1 overflow-auto">
                <DialogueOutline
                  document={document}
                  onPassageClick={handleOutlinePassageClick}
                  currentPassageId={currentPassageId || undefined}
                />
              </div>
            </div>
            <div className="w-px bg-border" />
          </>
        )}

        {/* Left pane - Rendered view with AI suggestions */}
        <Card className="m-2 overflow-auto flex flex-col" style={{ width: `${splitPosition}%`, minWidth: '20%', maxWidth: '80%' }}>
          <div className="p-4 flex-shrink-0">
            <h2 className="text-lg font-semibold mb-2">Rendered View</h2>
          </div>

          {/* AI Suggestions Panel */}
          {aiMode !== 'manual' && suggestions.length > 0 && (
            <div className="px-4 pb-2 flex-shrink-0">
              <InlineSuggestions
                suggestions={suggestions}
                onAccept={handleAcceptSuggestion}
                onReject={handleRejectSuggestion}
                highlightedText={selectedText}
                aiMode={aiMode}
              />
            </div>
          )}

          {/* Auto-Application Progress (AI Auto mode) */}
          {aiMode === 'auto' && isAutoApplying && (
            <div className="px-4 pb-2 flex-shrink-0">
              <Alert className="bg-blue-50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-900">
                <Loader2 className="h-4 w-4 animate-spin text-blue-600" />
                <AlertDescription className="text-sm">
                  <div className="flex items-center justify-between mb-2">
                    <span className="font-medium text-blue-900 dark:text-blue-100">
                      Auto-applying high-confidence suggestions...
                    </span>
                    <span className="text-xs text-blue-700 dark:text-blue-300">
                      {autoApplyProgress.current} / {autoApplyProgress.total}
                    </span>
                  </div>
                  <Progress
                    value={(autoApplyProgress.current / autoApplyProgress.total) * 100}
                    className="h-1"
                  />
                </AlertDescription>
              </Alert>
            </div>
          )}

          {/* Undo Toast for Auto-Applied Suggestions */}
          {showUndoToast && autoAppliedSuggestions.length > 0 && (
            <div className="px-4 pb-2 flex-shrink-0">
              <Alert className="bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-900">
                <CheckCircle2 className="h-4 w-4 text-green-600" />
                <AlertDescription className="text-sm">
                  <div className="flex items-center justify-between">
                    <span className="text-green-900 dark:text-green-100">
                      <span className="font-medium">Auto-applied {autoAppliedSuggestions.length} suggestion{autoAppliedSuggestions.length > 1 ? 's' : ''}</span>
                      {' '}with high confidence (≥80%)
                    </span>
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={handleUndoAutoApplied}
                      className="ml-2 h-7 text-xs"
                    >
                      <Undo className="h-3 w-3 mr-1" />
                      Undo
                    </Button>
                  </div>
                </AlertDescription>
              </Alert>
            </div>
          )}

          {/* Rendered content */}
          <div className="flex-1 overflow-auto">
            <RenderedView
              isBulkMode={isBulkMode}
              selectedPassages={selectedPassages}
              onSelectionChange={setSelectedPassages}
              onPassageClick={(passageId) => console.log('Passage clicked:', passageId)}
              highlightedPassageId={highlightedPassageId}
            />
          </div>
        </Card>

        {/* Resizer */}
        <div
          className={`w-1 bg-border cursor-col-resize transition-colors ${
            isDragging ? 'bg-primary' : 'hover:bg-primary'
          }`}
          onMouseDown={handleMouseDown}
          style={{ left: `${splitPosition}%` }}
        />

        {/* Right pane - Source view */}
        <Card className="m-2 overflow-auto" style={{ width: `${100 - splitPosition}%`, minWidth: '20%', maxWidth: '80%' }}>
          <div className="p-4">
            <h2 className="text-lg font-semibold mb-2">TEI Source</h2>
            <pre className="text-sm bg-muted p-2 rounded">
              {document.serialize()}
            </pre>
          </div>
        </Card>

        {/* Visualization Panel (toggleable sidebar) */}
        {vizPanelOpen && (
          <>
            <div className="w-1 bg-border" />
            <VisualizationPanel />
          </>
        )}
      </div>

      {/* Toast Notifications */}
      {toast && (
        <div className="fixed bottom-4 right-4 z-50 animate-in slide-in-from-bottom-5">
          <Alert className={`shadow-lg ${
            toast.type === 'success' ? 'bg-green-50 dark:bg-green-950/20 border-green-200 dark:border-green-900' :
            toast.type === 'error' ? 'bg-red-50 dark:bg-red-950/20 border-red-200 dark:border-red-900' :
            'bg-blue-50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-900'
          }`}>
            {toast.type === 'success' && <CheckCircle2 className="h-4 w-4 text-green-600" />}
            {toast.type === 'error' && <X className="h-4 w-4 text-red-600" />}
            {toast.type === 'info' && <Navigation className="h-4 w-4 text-blue-600" />}
            <AlertDescription className="text-sm ml-2">
              {toast.message}
            </AlertDescription>
          </Alert>
        </div>
      )}
    </div>
  );
}
