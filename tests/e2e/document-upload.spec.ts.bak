import { test, expect } from '@playwright/test';
import { writeFileSync, unlinkSync, existsSync } from 'fs';
import { join } from 'path';
import { TEIEditorApp } from './protocol/TEIEditorApp';
import { TEIDocument } from './fixtures/TEIDocument';
import { generateTestDocument, createMinimalTEI, createMalformedTEI } from './fixtures/test-helpers';
import { TIMEOUTS, SPEAKERS } from './fixtures/test-constants';

/**
 * Document Upload/Import E2E Tests (Protocol-Based)
 *
 * Comprehensive test coverage for document upload and import functionality including:
 * - Basic upload operations
 * - File type validation
 * - TEI format variants
 * - Edge cases and error handling
 * - Large documents and special characters
 *
 * Migrated from DOM-based to protocol-based testing using TEIEditorApp
 */

test.describe('Document Upload - Basic Operations', () => {
  test('should upload valid TEI document', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const doc = TEIDocument.valid({
      title: 'Test Document',
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA, SPEAKERS.JIM],
      passages: 5,
    });

    const state = await app.editor().load(doc);

    expect(state.location).toBe('editor');
    expect(state.document?.loaded).toBe(true);
    expect(state.document?.passageCount).toBe(5);
  });

  test('should reject non-XML file (.txt)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // FileProtocol will automatically ensure editor state
    const state = await app.files().uploadInvalid('This is plain text content', 'test-file.txt');

    // Should not load document
    expect(state.document?.loaded).toBe(false);
  });

  test('should reject non-XML file (.json)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const state = await app.files().uploadInvalid(JSON.stringify({ data: 'test' }), 'test-file.json');

    expect(state.document?.loaded).toBe(false);
  });

  test('should reject binary file (.jpg)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const buffer = Buffer.from([0xff, 0xd8, 0xff, 0xe0]);
    const state = await app.files().uploadBinary(buffer, 'test-image.jpg');

    expect(state.document?.loaded).toBe(false);
  });

  test('should show loading indicator during upload', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // Create a larger document to ensure visible loading
    const doc = TEIDocument.valid({
      title: 'Large Document',
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA],
      passages: 50,
    });

    const startTime = Date.now();
    const state = await app.editor().load(doc);
    const loadTime = Date.now() - startTime;

    expect(state.location).toBe('editor');
    expect(state.document?.loaded).toBe(true);
    expect(state.document?.passageCount).toBe(50);

    // Should load in reasonable time
    expect(loadTime).toBeLessThan(10000);
  });

  test('should handle rapid file uploads', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const doc1 = TEIDocument.valid({
      title: 'Document 1',
      speakers: ['speaker1'],
      passages: 3,
    });

    const doc2 = TEIDocument.valid({
      title: 'Document 2',
      speakers: ['speaker2'],
      passages: 5,
    });

    // Upload first document
    let state = await app.editor().load(doc1);
    expect(state.document?.passageCount).toBe(3);

    // Upload second document immediately after
    state = await app.editor().load(doc2);
    expect(state.document?.passageCount).toBe(5);
  });
});

test.describe('TEI Format Variants', () => {
  test('should handle TEI with namespace declarations', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const teiWithNS = generateTestDocument({
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA],
      passages: 5,
      namespaces: true,
      declarations: true,
    });

    await app.files().uploadRaw(teiWithNS, 'with-namespace.tei.xml');

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(5);
  });

  test('should handle TEI without namespace (backward compatibility)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const teiWithoutNS = generateTestDocument({
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA],
      passages: 5,
      namespaces: false,
      declarations: true,
    });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'without-namespace.tei.xml');
    writeFileSync(tempPath, teiWithoutNS);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(5);
  });

  test('should handle TEI without XML declaration', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const teiNoDecl = generateTestDocument({
      speakers: [SPEAKERS.NARRATOR],
      passages: 3,
      namespaces: true,
      declarations: false,
    });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'no-declaration.tei.xml');
    writeFileSync(tempPath, teiNoDecl);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(3);
  });

  test('should handle TEI with custom header metadata', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let customTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    customTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    customTEI += '  <teiHeader>\n';
    customTEI += '    <fileDesc>\n';
    customTEI += '      <titleStmt>\n';
    customTEI += '        <title>Custom Document Title</title>\n';
    customTEI += '        <author>Test Author</author>\n';
    customTEI += '      </titleStmt>\n';
    customTEI += '    </fileDesc>\n';
    customTEI += '  </teiHeader>\n';
    customTEI += '  <text>\n';
    customTEI += '    <body>\n';
    customTEI += '      <p><s who="#speaker1">Test passage</s></p>\n';
    customTEI += '    </body>\n';
    customTEI += '  </text>\n';
    customTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'custom-header.tei.xml');
    writeFileSync(tempPath, customTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const title = await app.editor().getTitle();
    expect(title).toBe('Custom Document Title');
  });

  test('should handle different TEI versions', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // TEI P5 with standard namespace
    let teiP5 = '<?xml version="1.0" encoding="UTF-8"?>\n';
    teiP5 += '<TEI xmlns="http://www.tei-c.org/ns/1.0" version="5.0">\n';
    teiP5 += '  <teiHeader><fileDesc><titleStmt><title>P5</title></titleStmt></fileDesc></teiHeader>\n';
    teiP5 += '  <text><body><p><s who="#narrator">P5 content</s></p></body></text>\n';
    teiP5 += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'tei-p5.tei.xml');
    writeFileSync(tempPath, teiP5);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const title = await app.editor().getTitle();
    expect(title).toBe('P5');
  });
});

test.describe('Edge Cases', () => {
  test('should handle empty document (no passages)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const emptyTEI = createMinimalTEI({ passages: [] });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'empty.tei.xml');
    writeFileSync(tempPath, emptyTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    // Should either not load or show empty state
    const state = await app.getState();
    // Document may or may not load, but if it does, passage count should be 0
    if (state.document?.loaded) {
      expect(state.document.passageCount).toBe(0);
    }
  });

  test('should handle document with only speakers (no dialogue)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let speakersOnly = '<?xml version="1.0" encoding="UTF-8"?>\n';
    speakersOnly += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    speakersOnly += '  <teiHeader>\n';
    speakersOnly += '    <fileDesc>\n';
    speakersOnly += '      <titleStmt><title>Speakers Only</title></titleStmt>\n';
    speakersOnly += '    </fileDesc>\n';
    speakersOnly += '  </teiHeader>\n';
    speakersOnly += '  <text>\n';
    speakersOnly += '    <body>\n';
    speakersOnly += '      <castList>\n';
    speakersOnly += '        <castItem>\n';
    speakersOnly += '          <role xml:id="speaker1">Speaker 1</role>\n';
    speakersOnly += '        </castItem>\n';
    speakersOnly += '        <castItem>\n';
    speakersOnly += '          <role xml:id="speaker2">Speaker 2</role>\n';
    speakersOnly += '        </castItem>\n';
    speakersOnly += '      </castList>\n';
    speakersOnly += '    </body>\n';
    speakersOnly += '  </text>\n';
    speakersOnly += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'speakers-only.tei.xml');
    writeFileSync(tempPath, speakersOnly);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(0);
  });

  test('should handle large document (>100KB)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // Generate a large TEI document with enough passages to exceed 100KB
    const largeTEI = generateTestDocument({
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA, SPEAKERS.JIM, SPEAKERS.PROTAGONIST],
      passages: 1500,
    });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'large-test.tei.xml');
    writeFileSync(tempPath, largeTEI);

    // Check file size
    const fs = await import('fs');
    const { size } = fs.statSync(tempPath);

    // Verify it's larger than 100KB
    expect(size).toBeGreaterThan(100 * 1024);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    // Wait for load with extended timeout
    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBeGreaterThan(0);

    unlinkSync(tempPath);
  });

  test('should handle very large document (>500 passages)', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const veryLargeTEI = generateTestDocument({
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA],
      passages: 600,
    });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'very-large.tei.xml');
    writeFileSync(tempPath, veryLargeTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    // Give extra time for very large document
    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBeGreaterThan(0);
  });

  test('should handle documents with Unicode characters', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let unicodeTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    unicodeTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    unicodeTEI += '  <teiHeader><fileDesc><titleStmt><title>Unicode Test</title></titleStmt></fileDesc></teiHeader>\n';
    unicodeTEI += '  <text><body>\n';
    unicodeTEI += '    <p><s who="#speaker1">Hello ‰∏ñÁïå ŸÖÿ±ÿ≠ÿ®ÿß ‡§π‡§ø‡§®‡•Ä</s></p>\n';
    unicodeTEI += '    <p><s who="#speaker2">Caf√© r√©sum√© na√Øve</s></p>\n';
    unicodeTEI += '    <p><s who="#speaker3">ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</s></p>\n';
    unicodeTEI += '  </body></text>\n';
    unicodeTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'unicode.tei.xml');
    writeFileSync(tempPath, unicodeTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(3);
  });

  test('should handle documents with emoji characters', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let emojiTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    emojiTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    emojiTEI += '  <teiHeader><fileDesc><titleStmt><title>Emoji Test</title></titleStmt></fileDesc></teiHeader>\n';
    emojiTEI += '  <text><body>\n';
    emojiTEI += '    <p><s who="#speaker1">Hello üòä üëç üéâ</s></p>\n';
    emojiTEI += '    <p><s who="#speaker2">Emoji test üöÄ ‚ú®</s></p>\n';
    emojiTEI += '  </body></text>\n';
    emojiTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'emoji.tei.xml');
    writeFileSync(tempPath, emojiTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(2);
  });

  test('should handle documents with special XML characters', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let specialCharsTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    specialCharsTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    specialCharsTEI += '  <teiHeader><fileDesc><titleStmt><title>Special Chars</title></titleStmt></fileDesc></teiHeader>\n';
    specialCharsTEI += '  <text><body>\n';
    specialCharsTEI += '    <p><s who="#speaker1">&lt;tag&gt; &amp; &quot;quotes&quot;</s></p>\n';
    specialCharsTEI += '    <p><s who="#speaker2">Apostrophe&apos;s and more</s></p>\n';
    specialCharsTEI += '  </body></text>\n';
    specialCharsTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'special-chars.tei.xml');
    writeFileSync(tempPath, specialCharsTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(2);
  });

  test('should handle documents with nested XML structures', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let nestedTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    nestedTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    nestedTEI += '  <teiHeader><fileDesc><titleStmt><title>Nested</title></titleStmt></fileDesc></teiHeader>\n';
    nestedTEI += '  <text><body>\n';
    nestedTEI += '    <p><s who="#speaker1">First passage</s></p>\n';
    nestedTEI += '    <p><s who="#speaker2">Second passage</s></p>\n';
    nestedTEI += '  </body></text>\n';
    nestedTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'nested.tei.xml');
    writeFileSync(tempPath, nestedTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBeGreaterThan(0);
  });

  test('should handle document with multiple paragraphs per passage', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    let multiParaTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    multiParaTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    multiParaTEI += '  <teiHeader><fileDesc><titleStmt><title>Multi Para</title></titleStmt></fileDesc></teiHeader>\n';
    multiParaTEI += '  <text><body>\n';
    multiParaTEI += '    <p><s who="#speaker1">First paragraph</s></p>\n';
    multiParaTEI += '    <p><s who="#speaker2">Second paragraph</s></p>\n';
    multiParaTEI += '    <p><s who="#speaker1">Third paragraph</s></p>\n';
    multiParaTEI += '  </body></text>\n';
    multiParaTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'multi-para.tei.xml');
    writeFileSync(tempPath, multiParaTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await app.waitForState({
      location: 'editor',
      document: { loaded: true },
    });

    unlinkSync(tempPath);

    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(3);
  });
});

test.describe('Validation and Error Handling', () => {
  test('should detect malformed XML with unclosed tag', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const malformedTEI = createMalformedTEI({ error: 'unclosed-tag' });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'malformed-unclosed.tei.xml');
    writeFileSync(tempPath, malformedTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    // Should not load the document
    const state = await app.getState();
    expect(state.document?.loaded).toBe(false);
  });

  test('should detect malformed XML with invalid entities', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const malformedTEI = createMalformedTEI({ error: 'invalid-xml' });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'malformed-entity.tei.xml');
    writeFileSync(tempPath, malformedTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    const state = await app.getState();
    expect(state.document?.loaded).toBe(false);
  });

  test('should detect missing root element', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const malformedTEI = createMalformedTEI({ error: 'missing-root' });

    const tempPath = join(process.cwd(), 'tests/fixtures', 'malformed-root.tei.xml');
    writeFileSync(tempPath, malformedTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    const state = await app.getState();
    expect(state.document?.loaded).toBe(false);
  });

  test('should reject completely empty file', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const tempPath = join(process.cwd(), 'tests/fixtures', 'empty.xml');
    writeFileSync(tempPath, '');

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    const state = await app.getState();
    expect(state.document?.loaded).toBe(false);
  });

  test('should reject file with only whitespace', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const tempPath = join(process.cwd(), 'tests/fixtures', 'whitespace.xml');
    writeFileSync(tempPath, '   \n\n  \t  \n  ');

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    const state = await app.getState();
    expect(state.document?.loaded).toBe(false);
  });

  test('should validate required TEI elements', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // TEI without required teiHeader
    let incompleteTEI = '<?xml version="1.0" encoding="UTF-8"?>\n';
    incompleteTEI += '<TEI xmlns="http://www.tei-c.org/ns/1.0">\n';
    incompleteTEI += '  <text><body>\n';
    incompleteTEI += '    <p><s who="#speaker1">Content</s></p>\n';
    incompleteTEI += '  </body></text>\n';
    incompleteTEI += '</TEI>\n';

    const tempPath = join(process.cwd(), 'tests/fixtures', 'incomplete.tei.xml');
    writeFileSync(tempPath, incompleteTEI);

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    // Parser may still accept this depending on strictness
    const state = await app.getState();
    // If content shows, parser is lenient (which is fine)
    if (state.document?.loaded) {
      expect(state.document.passageCount).toBeGreaterThan(0);
    }
  });

  test('should handle XML with encoding issues', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // Create file with mismatched encoding declaration vs content
    const tempPath = join(process.cwd(), 'tests/fixtures', 'encoding-test.tei.xml');
    writeFileSync(
      tempPath,
      '<?xml version="1.0" encoding="ISO-8859-1"?>\n<TEI>Content</TEI>',
      'utf-8'
    );

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    // Browser should handle encoding gracefully
    const state = await app.getState();
    // May or may not load depending on browser handling
  });
});

test.describe('Upload UI Interactions', () => {
  test('should preserve document state after failed upload attempt', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    // Load a valid document first
    const validTEI = TEIDocument.valid({
      title: 'Initial Document',
      speakers: [SPEAKERS.NARRATOR],
      passages: 3,
    });

    let state = await app.editor().load(validTEI);
    expect(state.document?.passageCount).toBe(3);

    // Try to upload invalid file
    const tempPath = join(process.cwd(), 'tests/fixtures', 'invalid.xml');
    writeFileSync(tempPath, '<invalid></invalid');

    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(tempPath);

    await page.waitForTimeout(1000);
    unlinkSync(tempPath);

    // Original document should still be visible
    state = await app.getState();
    expect(state.document?.passageCount).toBe(3);
  });

  test('should allow re-uploading different documents', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const doc1 = TEIDocument.valid({
      title: 'First Document',
      speakers: ['speaker1'],
      passages: 2,
    });

    const doc2 = TEIDocument.valid({
      title: 'Second Document',
      speakers: ['speaker2', 'speaker3'],
      passages: 4,
    });

    // Upload first document
    let state = await app.editor().load(doc1);
    expect(state.document?.passageCount).toBe(2);

    // Upload second document (should replace first)
    state = await app.editor().load(doc2);

    // Wait a bit for document replacement
    await page.waitForTimeout(500);

    // The document should be replaced
    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBeGreaterThan(0);
  });
});

test.describe('Performance and Stress Tests', () => {
  test('should handle document with 1000 passages', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const doc = TEIDocument.valid({
      title: 'Massive Document',
      speakers: [SPEAKERS.NARRATOR, SPEAKERS.DELLA, SPEAKERS.JIM],
      passages: 1000,
    });

    const startTime = Date.now();
    const state = await app.editor().load(doc);
    const loadTime = Date.now() - startTime;

    // Should load within reasonable time (<30 seconds)
    expect(loadTime).toBeLessThan(30000);

    // Should have loaded the document
    expect(state.document?.loaded).toBe(true);
    expect(state.document?.passageCount).toBeGreaterThan(0);
  });

  test('should handle multiple rapid uploads without memory issues', async ({ page }) => {
    const app = await TEIEditorApp.create(page);

    const documents = [
      TEIDocument.valid({ title: 'Doc 1', speakers: ['s1'], passages: 10 }),
      TEIDocument.valid({ title: 'Doc 2', speakers: ['s2'], passages: 20 }),
      TEIDocument.valid({ title: 'Doc 3', speakers: ['s3'], passages: 30 }),
      TEIDocument.valid({ title: 'Doc 4', speakers: ['s4'], passages: 40 }),
      TEIDocument.valid({ title: 'Doc 5', speakers: ['s5'], passages: 50 }),
    ];

    for (let i = 0; i < documents.length; i++) {
      const state = await app.editor().load(documents[i]);
      expect(state.document?.loaded).toBe(true);
    }

    // Final document should be loaded correctly
    const passageCount = await app.editor().getPassageCount();
    expect(passageCount).toBe(50);
  });
});
